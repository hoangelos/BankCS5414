Each node stores the set of tuples (sender, serial-number) that it has seen.

In the most general case, where our only restriction is that a given sender will use unique but potentially arbitrary serial numbers among unique messages, it is necessary to store this set because our only guarantee is that a yet-unseen message has a yet-unseen serial number. This has the disadvantage that it grows without bound as new messages come in and may therefore be unrealistic.

Alternatively, we could have used some sort of ordering-based scheme, where newer serial numbers must compare as greater than older serial numbers. In this case, we only need to store a map from sender to the greatest serial number we have seen from them. This caps our per-sender storage requirement to a constant, but the disadvantage is that it requires that messages come in the prescribed order. A message with a given serial number is also a revocation of everything with a lower number, and so we would need additional mechanisms in the system to ensure that requests constructed previously with lower serial numbers were already completed or discarded before a given request is made.

Each sender generates its own sequence of serial numbers. Each one is generated on-demand through the concatenation of a high-enough-resolution clock and a rolling counter, with the assumption that we will traverse a full loop of the range of the counter in a given unit of time resolution.

The inclusion of serial numbers allows our messages to be idempotent. It is safe to send a given message multiple times while only causing its effect to happen once. In a world view where failures occur, it would be acceptable to keep resending a given message until we received its acknowledgement. Then, we would be sure that it was received at least once and executed exactly once.

